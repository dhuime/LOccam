<head>
<link href="style.css" media="screen" rel="stylesheet type="text/css"" />
<title> LOccam</title>
<meta charset="UTF-8"/>
<script type="text/javascript"
  src="MathJax/MathJax.js?config=AM_HTMLorMML-full">
</script>
</head>

<body style="width:700px;">


<h4 id="pol3"> Interrupts</h4>
<p>
<b>Binary semaphores</b><br><br>
Binary semaphores are the tool we use to link  interrupts  to processes.<br>
In what follows we remind the properties of such semaphores.<br><br>
<b>Declaring a semaphore (not necessary a binary one)</b><br><br>
A semaphore as type sem_t . ( shorthand for RTOS SemaphoreHandle_t  ).<br><br>
Invoking the function semCreateBinary ( shorthand for RTOS xSemaphoreCreateBinary)  make it recognized
 by RTOS as a binary semaphore.<br>
</p>
<pre id="code">

 sem_t semBin ; declare semBin as a semaphore
 
 prototype : sem_t semCreateBinary() .
 example   : semBin = semCreateBinary()	;

</pre>
<p>
<b>semGive and semTake</b><br><br>
semGive is a shorthand for RTOS xSemaphoreGive and semGet a shorthand for xSemaphoreTake .<br>
These two functions are the <b>only one</b> devoted to a semaphore access.
</p>
<pre id="code">

 prototypes : void semGive(sem_t) , void  semTake(sem_t)
 example    : semGive(semBin) ;   semTake(semBin) ;

</pre>

<p>
<b>Managing binary semaphores</b><br><br>
In what follows S is a binary semaphore  .<br>
Binary semaphores take only two values : 0 and 1 but we cannot read them.<br>
After the declaration  S = semCreateBinary() the value of S is 0 .<br><br>
<b>semGive</b><br><br>
A process P execute semGive(S) .<br>
If there exist a process Q suspended on that semaphore then Q is no longer suspended and becomes ready for 
executing .<br>
Else the value of S is set to 1 .<br>
A process who execute semGive is NEVER suspended .<br><br>

<b>semTake</b><br><br>
A process P execute semTake(S) .<br>
If the value of S is 0 then the process is suspended .<br>
Else the value of S is set to 0 and the process continue executing .<br><br>

<b>Managing interrupts</b><br><br>
Interrupts are managed by Arduino's function :
<a href= "https://www.arduino.cc/en/Reference/AttachInterrupt"> attachInterrupt() </a>  .<br>
The two first parameters of that  function are respectively : an interrupt number and a function identifier .<br>
The third one denotes the mode the interrupt should be triggered . <br>
Here we are concerned by the function who appears as second parameter.<br>
That function ( the Handler of the interrupt) simply execute semGive(S) when an interrupt occur .<br>
A process P who execute, as first instruction semTake(S) is suspended . ( remind S as value 0 when declared)<br>
When an interrupt occur the Handler is called and  P may execute is code. That's all .<br><br>

<b>Example</b><br><br>
In that example interrupts are generated by pushing a button . ( see shematics).<br>
The program implements 3 processes . button, process and Control.<br>
Control is an alternation process with two channels 0 and 1 as inputs.<br>
button if activated by the interrupts handler   write in the channel 0 of Control .<br>
process write in the channel 1 of Control every second .<br><br><br><br>
<img src="images/itrupts.png" alt="interruptions" style="float:left;width:227px;height:393px;">


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</p>


<pre id="code">

// intrupt.ino

#include < LOccam.h >

sem_t semBin    ;
ALT  altrn      ;

void Handler(){                   // active when button's down
    semGive(semBin)             ;
}


PROC button(void *pvParameters){  
  static ALT *palt              ;
  static MSG msg                ;

  palt = (ALT *)pvParameters    ;
  msg.canal = 0                 ;
  msg.data = 100                ;
  
  while(1){
      semTake(semBin)           ; // suspended . wait for button's down
      writeALT(palt, msg)       ; // write on channel 0 when ready
      msg.data++                ;
  }
}

PROC process(void *pvParameters){ // write channel 1 every second
  static ALT *palt             ;
  static MSG  msg              ;

  palt = (ALT *)pvParameters  ;
  msg.canal = 1               ;
  msg.data  = 0               ;
  
  while(TRUE){
    WAIT(1000)                ;
    writeALT(palt, msg)       ;
    msg.data++                ;
  }
}

PROC Control(void *pvParameters){
  static ALT *palt  ;
  static MSG msg    ;

  palt = (ALT *)pvParameters  ;
  while(TRUE){
      msg = readALT(palt)     ;
      switch(msg.canal){
              case 0:{
                  Serial.print("IT CANAL0 : ");
                  Serial.println(msg.data)    ;
                  break         ;
              }
              case 1:{
                  Serial.println(msg.data);
                  break         ;
              }
              default:  break   ;
        } // switch
  }
}


void setup(){
    Serial.begin(9600)                     ;
    
    attachInterrupt(0,Handler,FALLING)     ; // interrupt 0 (broche D2 ATMega2560)

    semBin = semCreateBinary()             ;
    
    NEWALT(&altrn, 2)                      ;
        
    PAR(button ,  &altrn)                  ;
    PAR(process,  &altrn)                  ;
    PAR(Control,  &altrn)                  ;
    START()                                ;
}

void loop(){}

</pre>


</body>
</html>
