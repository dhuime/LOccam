<!DOCTYPE html>
<html>

<head>
<link href="style.css" media="screen" rel="stylesheet type="text/css"" />
<title> LOccam</title>
<meta charset="UTF-8"/>
<script type="text/javascript"
  src="MathJax/MathJax.js?config=AM_HTMLorMML-full">
</script>
</head>

<body style="width:700px;">


<h4 id="pol3"> Channels</h4>
<p>
OCCAM channels are the  only mean by which processes communicate.<br>
Channels provides unbuffered unidirectionnal point to point communication between two concurrent processes.<br>
Communication in channels  implements a "rendez vous". The first process ready (to read or write in the channel)
is suspended. When the second one is ready  then data transfert occur
 and the two processes continue executing their code.<br>
LOccam fully implements OCCAM channels but the data type transfered is only the int type . <br><br>

<b>Channel declaration</b><br><br>
A channel has  data type CHAN  .
</p>
<pre id="code">

 CHAN canal0, canal1  ; // declare two channels : canal0 and canal1
 CHAN canaux[20]      ; // declare an array of 20 channels

</pre>
<p><b>
Referencing channels</b><br><br>
Referencing channels is the mean by which they are recognized by RTOS .<br>
The function NEWCHAN  make it  possible .
</p>
<pre id="code">

 prototype : void NEWCHAN(CHAN *)
 
 Examples :
 NEWCHAN(&canal0)  ;
 for(i=0; i< 20 ; i++) NEWCHAN(&canaux[i]) ;

</pre>

<p>
<b>Reading and writing channels</b><br><br>
Reading and writing in channels is done by the functions readCHAN and writeCHAN.
</p>
<pre id="code">

 prototype : int readCHAN(CHAN *)         // read a channel . return an int.
 prototype : void writeCHAN(CHAN *, int)  // write an int into a channel

</pre>
<p>
<b>A simple program</b><br><br>
In this program the process proc0 write 100 in the channel mcanal . The process proc1 is reading
mcanal. <br>
For the ease of viewing the "rendez vous" protocol the function WAIT in proc0 forces
proc1 to begin the first so it is suspending in the reading of mcanal.<br>
</p>
<pre id="code">

  // canal.ino
 

#include < LOccam.h >

CHAN mcanal                           ;

PROC  proc0(void *pvParameters){      // write mcanal
    static CHAN *pchan                ;

    pchan = (CHAN *)pvParameters      ;
    WAIT(2)                           ; //  suspended 2 milli seconds 
    Serial.println("\nP0 emet 100")   ;
    writeCHAN(pchan, 100)             ; 
    Serial.print("\nP0 : BY ...")     ;
    EXIT()                            ;
}

PROC  proc1(void *pvParameters){      // read mcanal
    static int recu                   ;
    static CHAN *pchan                ;

    pchan = (CHAN *)pvParameters      ;
    Serial.print("P1 first : ")       ;
    recu = readCHAN(pchan)            ;
    
    Serial.print("\nP1 a recu : ")    ;
    Serial.print(recu)                ;
    Serial.print("\nP1 : BY ...")     ;
    EXIT()                            ;
}


void setup() {

  Serial.begin(9600)        ;
  Serial.flush()            ;
  
  NEWCHAN(&mcanal)          ;
  
  PAR(proc0, &mcanal)       ; // passing mcanal as parameter
  PAR(proc1, &mcanal)       ;
  START(NULL)               ;
}

void loop() {}

</pre>

<p>
<b>A simple token ring</b><br><br>
In this example a ring of 5 processes behave as a (simplified) token ring.<br>
This type of interconnection of processes is the most simple one.<br>
In the ring a token is running passing from one process to its successor.<br> 
If the token is free a process who want to communicate take the token and code in it <br>
the index of destination , the index of emitter (himself) , and data.<br>
In the example a processor of index i who have the token ( when he receive it) write to the process<br>
at index (i+2) modulo 5 . So after 2 runs all processers have communicated .<br>
More precisely process 0 emit in direction of process 2 , 2 in direction of 4, 4 in direction<br>
of 1 in direction of 3 and at the end 3 in direction of 0 .

</p>
<pre id="code">

// tokenring.ino

#include < LOccam.h >


// token's coding

/*
bits 2..0   destinataire
bits 5..3   emetteur
bits 6..7   ........
bits 8..15  data
*/

/////////////////////////////////////////////////

CHAN canal[5]               ;
int procid[5]               ;


int  setJeton(int dest, int emet,  int data){
  int mj                    ;		// coding the token
  
  mj = dest                 ;
  mj = mj | (emet << 3)     ;
  mj = mj | (data << 8 )    ;
  return mj                 ;
}

int read_dest(u_int jeton){		// decode receiver
  return jeton & 0x7        ;
}

int read_emet(u_int jeton){ 		// decode emitter
  return (jeton & 0x38) >> 3    ; 
}


int read_data(u_int jeton){		// decode data
  return (jeton & 0xFF00) >> 8  ;
}

///////////////////////////////////////////

PROC init(void *pvParameters){
  int jeton , dest , emet, data         ; // init has index 0
  
  jeton = setJeton(2,0,10)              ; // 0 emit 10 in direction of 2
  writeCHAN(((CHAN *)&canal[0]), jeton) ;
  
  ///////
  
  jeton = readCHAN(((CHAN *)&canal[4])) ; // first run
  dest = read_dest(jeton)               ;
  
  writeCHAN(((CHAN *)&canal[0]), jeton) ;
  jeton = readCHAN(((CHAN *)&canal[4])) ; // second and last run
  
  dest = read_dest(jeton)               ;
  data = read_data(jeton)               ;
  emet = read_emet(jeton)               ;
  Serial.print("process : ")            ;
  Serial.print(0)                       ;
  Serial.print(" a recu : ")            ;
  Serial.print(data)                    ;
  Serial.print(" de : ")                ;
  Serial.println(emet)                  ;
  WAIT(100)                             ;
  Serial.println("\n STOP tokenring running .  BY  ")  ;
  EXIT()                                ;
}


PROC  process(void *pvParameters){
  int *id, pid , dest , emet            ;
  int data ,  tour                      ;
  int jeton                             ;

   id = (int *)pvParameters             ;
   pid = *id                            ; // pid = index of process 
   tour = 0                             ;
   do{
      jeton = readCHAN(((CHAN *)&canal[pid-1])) ;
      tour++                            ;
      dest = read_dest(jeton)           ;
      if(dest == pid){
          data = read_data(jeton)       ;
          emet = read_emet(jeton)       ;
          Serial.print("process : ")    ;
          Serial.print(pid)             ;
          Serial.print(" a recu : ")    ;
          Serial.print(data)            ;
          Serial.print(" de : ")        ;
          Serial.println(emet)          ;
          
          data = pid + 10               ; // emit pid+10 in direction of (pid+2)%5 
          dest = (pid + 2) %5           ;
          jeton = setJeton(dest,pid,data) ;
      }
      writeCHAN(((CHAN *)&canal[pid]), jeton)  ;
   }  while(tour < 2)                   ;
   EXIT()                               ;
} // process


void setup() {
  int i ;
  
  Serial.begin(9600)        ;
  for(i=0;i<5;i++){ 
    NEWCHAN(&canal[i])      ;
    procid[i] = i           ; 
  }

  PAR(init, NULL)           ;
  for(i=1 ;i<5;i++) PAR(process, procid+i)   ;
  START(NULL)                   ;
}

void loop() {}

</pre>
<p>
NB : In this example the array of channels is not passed as a parameter .<br>
The expression of readCHAN and writeCHAN may appear cumbersome . This fact 
shows a weakness of the Arduino compiler.<br><br>
The reader is ancouraged to pass as parameters both indexes and channels . Do
an ad-hoc structure.

</p>

</body>
</html>
